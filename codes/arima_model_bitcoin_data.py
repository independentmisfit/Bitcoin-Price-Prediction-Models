# -*- coding: utf-8 -*-
"""ARIMA MODEL BITCOIN DATA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1enKZewaq0R7nei0xYMZSlL99fLjuKQcP
"""

!pip install pmdarima

from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
from pmdarima import auto_arima
import pandas as pd
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

bitcoin_data = pd.read_csv('bitcoin data.csv')
bitcoin_data.tail()

bitcoin_data.isnull().sum()

bitcoin_data.duplicated().sum()

bitcoin_df = pd.DataFrame({
    'Start': pd.to_datetime(bitcoin_data['Start']),
    'Open': bitcoin_data['Open']
})
bitcoin_df.rename(columns={'Start': 'Date'}, inplace=True)
bitcoin_df.head()

new_bitcoin_df = bitcoin_df.iloc[29:]
new_bitcoin_df.sort_values(by='Date', inplace=True)
new_bitcoin_df.reset_index(drop=True, inplace=True)
new_bitcoin_df.head()

plt.figure(figsize=(10, 6))
plt.plot(new_bitcoin_df['Date'], new_bitcoin_df['Open'])
plt.xlabel('Year')
plt.ylabel('Price (USD)')
plt.title('Bitcoin Price Over Time (July 2010 - August 2024)')
plt.grid(True)
plt.show()

adfuller_result = adfuller(new_bitcoin_df['Open'])
print(f'ADF Statistic: {adfuller_result[0]}')
print(f'p-value: {adfuller_result[1]}')
#p-value: 0.7838909231706688
#data is stationary

plt.figure(figsize=(10, 6))
plot_acf(new_bitcoin_df['Open'], lags= 40)
plt.title('Autocorrelation Function')

plt.figure(figsize=(10, 6))
plot_pacf(new_bitcoin_df['Open'], lags = 40)
plt.title('Partial Autocorrelation Function')
plt.show()

new_bitcoin_df['Open Diff']= new_bitcoin_df['Open'].diff().fillna(0)
new_bitcoin_df.head()

adfuller_result2 = adfuller(new_bitcoin_df['Open Diff'])

print(f'ADF Statistic: {adfuller_result2[0]}')
print(f'p-value: {adfuller_result2[1]}')

plt.figure(figsize=(10, 6))
plt.plot(new_bitcoin_df['Date'], new_bitcoin_df['Open Diff'])
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('Differenced Bitcoin Price Over Time')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
plot_acf(new_bitcoin_df['Open Diff'], lags= 40)
plt.title('Autocorrelation Function')

plot_pacf(new_bitcoin_df['Open Diff'], lags = 40)
plt.title('Partial Autocorrelation Function')
plt.show()

from statsmodels.tsa.stattools import pacf, acf
import numpy as np
values, confint = pacf(new_bitcoin_df['Open Diff'], nlags = 40, alpha =0.05)
print(acf(new_bitcoin_df['Open Diff'], nlags=40))
print(values)

n = len(new_bitcoin_df['Open Diff'])
conf_int = 1.96/np.sqrt(n)
lower_bound = np.full_like(values, -conf_int)
upper_bound = np.full_like(values, conf_int)
print(lower_bound)
print(upper_bound)

auto_arima_model = auto_arima(new_bitcoin_df['Open'], seasonal=False, trace=True)
auto_arima_model.summary()



model = ARIMA(new_bitcoin_df['Open'], order=(2, 1, 2))
model_fit = model.fit()
model_fit.summary()

orders = [(1, 1, 1), (0, 1, 0), (1, 1, 0), (1, 1, 2), (2, 1, 0), (2, 1, 1), (2, 1, 2)]

# Create an empty list to store the results
results = []

# Loop through each model order
for order in orders:
    try:
        # Fit the ARIMA model
        model = ARIMA(new_bitcoin_df['Open'], order=order)
        model_fit = model.fit()

        # Get the AIC and BIC scores
        aic = model_fit.aic
        bic = model_fit.bic

        # Append the results to the list
        results.append([order, aic, bic])

    except Exception as e:
        print(f"Error with order {order}: {e}")

# Create a Pandas DataFrame from the results
results_df = pd.DataFrame(results, columns=['Order', 'AIC', 'BIC'])

# Print the results in a tabular form
print(results_df)

forecast_values = model_fit.forecast(steps=29)
last_date = new_bitcoin_df['Date'].iloc[-1]
forecast_dates = pd.date_range(start=last_date, periods=30, freq='D')[1:]
forecast_df = pd.DataFrame({'Date': forecast_dates, 'Forecast Values': forecast_values})
forecast_df

real_values = bitcoin_df.iloc[:29].sort_values(by='Date')
real_values

import matplotlib.cm as cm
# Choose a colormap
colormap = cm.viridis

# Plot DataFrame 1 with color based on value
plt.scatter(forecast_df['Date'], forecast_df['Forecast Values'], c=forecast_df['Forecast Values'], cmap=colormap, label='Forecasted Values')

# Plot DataFrame 2 with color based on value
plt.scatter(real_values['Date'], real_values['Open'], c=real_values['Open'], cmap=colormap, label='Actual Values')

# Add a colorbar
plt.colorbar()

# Customize the plot
plt.xlabel('Date')
plt.ylabel('Value')
plt.title('ARIMA Model Forecast Values vs. Actual Value Comparison of Bitcoin Prices for Septeber 2024')
plt.legend()
plt.show()

plt.plot(forecast_df['Date'], forecast_df['Forecast Values'], label='Forecasted Values')

# Plot DataFrame 2
plt.plot(real_values['Date'], real_values['Open'], label='Actual Values')

# Customize the plot
plt.xlabel('Date')
plt.ylabel('Value')
plt.title('ARIMA Model Forecast Values vs. Actual Value Comparison of Bitcoin Prices for Septeber 2024')
plt.legend()

# Rotate x-axis labels
plt.xticks(rotation=45, ha='right')

plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error
from math import sqrt
rmse = sqrt(mean_squared_error(real_values['Open'], forecast_df['Forecast Values']))
mae = mean_squared_error(real_values['Open'], forecast_df['Forecast Values'])
print(rmse)
print(mae)

from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error

mae = mean_absolute_error(real_values['Open'], forecast_df['Forecast Values'])
mape = mean_absolute_percentage_error(real_values['Open'], forecast_df['Forecast Values'])

print(f'MAE: {mae}')
print(f'MAPE: {mape}')