# -*- coding: utf-8 -*-
"""LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HFPTjLFEt6mHnASxDY7wLmWVt-Nh17tG
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

bitcoin_data = pd.read_csv('bitcoin data.csv')

bitcoin_data.isnull().sum()

bitcoin_data.duplicated().sum()

bitcoin_df = pd.DataFrame({
    'Start': pd.to_datetime(bitcoin_data['Start']),
    'Open': bitcoin_data['Open']
})
bitcoin_df.rename(columns={'Start': 'Date'}, inplace=True)
bitcoin_df.head()

new_bitcoin_df = bitcoin_df.iloc[29:]
new_bitcoin_df.sort_values(by='Date', inplace=True)
new_bitcoin_df.reset_index(drop=True, inplace=True)
new_bitcoin_df.head()

sc = MinMaxScaler(feature_range = (0, 1))
training_set_scaled = sc.fit_transform(new_bitcoin_df['Open'].values.reshape(-1, 1))

def create_dataset(dataset, time_step=60):
  X, y = [], []
  for i in range(time_step, len(dataset)):
    X.append(dataset[i-time_step:i, 0])
    y.append(dataset[i, 0])
  return np.array(X), np.array(y)

time_step = 60
X_train, y_train = create_dataset(training_set_scaled, time_step)
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)

model = Sequential()

model.add(LSTM(units = 50, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.2))

model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.2))

model.add(LSTM(units = 50))
model.add(Dropout(0.2))

model.add(Dense(units = 1))

model.compile(optimizer = 'adam', loss = 'mean_squared_error')

model.fit(X_train, y_train, epochs = 100, batch_size = 32)

real_values = bitcoin_df.iloc[:29].sort_values(by='Date')
real_values

dataset_total = pd.concat((new_bitcoin_df['Open'], real_values['Open']), axis = 0)
inputs = dataset_total[len(dataset_total) - len(real_values) - 60:].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)
X_test = []
for i in range(60, 89):
    X_test.append(inputs[i-60:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
predicted_price = model.predict(X_test)
predicted_price = sc.inverse_transform(predicted_price)

forecast_days = len(predicted_price)
last_date = new_bitcoin_df['Date'].iloc[-1]
last_date
future_dates = pd.date_range(start=last_date, periods=forecast_days+1, freq='D')
future_dates

# Convert predicted_price to a 1-dimensional array
predicted_price = predicted_price.flatten()

forecast_df = pd.DataFrame({'Date': future_dates[1:], 'Forecast Values': predicted_price})
forecast_df

plt.plot(forecast_df['Date'], forecast_df['Forecast Values'], label='Forecasted Values')

# Plot DataFrame 2
plt.plot(real_values['Date'], real_values['Open'], label='Actual Values')

# Customize the plot
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('LSTM Model Forecast Values vs. Actual Value Comparison of Bitcoin Prices for Septeber 2024')
plt.legend()

# Rotate x-axis labels
plt.xticks(rotation=45, ha='right')

plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error

rmse = mean_squared_error(real_values['Open'], predicted_price, squared=False)

print('RMSE:', rmse)

from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error

# Calculate RMSE
rmse = mean_squared_error(real_values['Open'], predicted_price, squared=False)

# Calculate MAE
mae = mean_absolute_error(real_values['Open'], predicted_price)

# Calculate MAPE
mape = mean_absolute_percentage_error(real_values['Open'], predicted_price)

# Print the results
print('RMSE:', rmse)
print('MAE:', mae)
print('MAPE:', mape)